# Напишите реализацию функции closest_mod_5, принимающую
# в качестве единственного аргумента целое число x и
# возвращающую самое маленькое целое число y, такое что:
# y больше или равно x
# y делится нацело на 5
# Формат того, что ожидается от вас в качестве ответа:
# def closest_mod_5(x):
#     if x % 5 == 0:
#         return x
#     return "I don't know :("
# '''

def closest_mod_5(x):
    if x % 5 == 0:
        return x
    return 5 - (x % 5) + x
print(closest_mod_5(6))


# Сочетанием из n элементов по k называется подмножество этих n элементов размера k.
# Два сочетания называются различными, если одно из сочетаний содержит элемент, который не содержит другое.
# Числом сочетаний из n по k называется количество различных сочетаний из n по k. Обозначим это число за C(n, k).
# Пример:
# Пусть n = 3, т. е. есть три элемента (1, 2, 3). Пусть k = 2.
# Все различные сочетания из 3 элементов по 2: (1, 2), (1, 3), (2, 3).
# Различных сочетаний три, поэтому C(3, 2) = 3.
# Несложно понять, что C(n, 0) = 1, так как из n элементов выбрать 0 можно единственным образом, а именно, ничего не выбрать.
# Также несложно понять, что если k > n, то C(n, k) = 0, так как невозможно, например, из трех элементов выбрать пять.
# Для вычисления C(n, k) в других случаях используется следующая рекуррентная формула:
# C(n, k) = C(n - 1, k) + C(n - 1, k - 1).
# Реализуйте программу, которая для заданных n и k вычисляет C(n, k).
# Вашей программе на вход подается строка, содержащая два целых числа n и k (1 ≤ n ≤ 10, 0 ≤ k ≤ 10).
# Ваша программа должна вывести единственное число: C(n, k).
# Примечание:
# Считать два числа n и k﻿ вы можете, например, следующим образом:
# n, k = map(int, input().split())
# Sample Input 1:
# 3 2
# Sample Output 1:
# 3
# Sample Input 2:
# 10 5
# Sample Output 2:
# 252
# '''

def C(n, k):
    if k == 0:
        return 1
    elif k > n:
        return 0
    else:
        return C(n - 1, k) + C(n - 1, k - 1)

n, k = map(int, input().split())
print(C(n, k))

# Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания пространств имен и добавление в них переменных.
# В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.
# Вашей программе на вход подаются следующие запросы:
# create namespace parent – создать новое пространство имен с именем namespace внутри пространства parent
# add namespace var – добавить в пространство namespace переменную var
# get namespace var – получить имя пространства, из которого будет взята переменная var при запросе из пространства namespace, или None, если такого пространства не существует
# Рассмотрим набор запросов
# add global a
# create foo global
# add foo b
# create bar foo
# add bar a
# Структура пространств имен описанная данными запросами будет эквивалентна структуре пространств имен, созданной при выполнении данного кода
# a = 0
# def foo():
#   b = 1
#   def bar():
#     a = 2
# В основном теле программы мы объявляем переменную a, тем самым добавляя ее в пространство global. Далее мы объявляем функцию foo, что влечет за собой создание локального для нее пространства имен внутри пространства global. В нашем случае, это описывается командой create foo global. Далее мы объявляем внутри функции foo функцию bar, тем самым создавая пространство bar внутри пространства foo, и добавляем в bar переменную a.
# Добавим запросы get к нашим запросам
# get foo a
# get foo c
# get bar a
# get bar b
# Представим как это могло бы выглядеть в коде
# a = 0
# def foo():
#   b = 1
#   get(a)
#   get(c)
#   def bar():
#     a = 2
#     get(a)
#     get(b)
# Результатом запроса get будет имя пространства, из которого будет взята нужная переменная. Например, результатом запроса get foo a будет global, потому что в пространстве foo не объявлена переменная a, но в пространстве global, внутри которого находится пространство foo, она объявлена. Аналогично, результатом запроса get bar b будет являться foo, а результатом работы get bar a будет являться bar.
# Результатом get foo c будет являться None, потому что ни в пространстве foo, ни в его внешнем пространстве global не была объявлена переменная с.
# Более формально, результатом работы get namespace var является
# namespace, если в пространстве namespace была объявлена переменная var
# get parent var – результат запроса к пространству, внутри которого было создано пространство namespace, если переменная не была объявлена
# None, если не существует parent, т. е. namespace﻿ – это global
# Формат входных данных
# В первой строке дано число n (1 ≤ n ≤ 100) – число запросов. В каждой из следующих n строк дано по одному запросу. Запросы выполняются в порядке, в котором они даны во входных данных. Имена пространства имен и имена переменных представляют из себя строки длины не более 10, состоящие из строчных латинских букв.
# Формат выходных данных
# # Для каждого запроса get выведите в отдельной строке его результат.
# # Sample Input:
# # 9
# add global a
# create foo global
# add foo b
# get foo a
# get foo c
# create bar foo
# add bar a
# get bar a
# get bar b
# Sample Output:
# global
# None
# bar
# foo
# Sample Output:
#
# global
# None
# bar
# foo
# Решение
# put your python code here
# put your python code here

def create(namesp, parent):
    for key in envs.keys(): # Пробегаем по ключам
        if parent == key[-1]: # Если последний элемент ключа равен родителю
            envs[key] += [namesp] # Добавляем пространство к родителю как переменную
            envs[key + (namesp,)] = [] # Создаем новое пространство, где ключ это кортеж с именами до global включительно
            return

def add(namesp, var):
    for key in envs.keys(): # Пробегаем по ключам
        if namesp == key[-1]: # Если последний элемент ключа равен требуему пространству
            envs[key] += [var] # Добавляем в список переменных новую

def get(namesp, var):
    for key in envs.keys(): # Пробегаем по ключам
        while namesp == key[-1]: # Пока имя пространства совпадает с последним элементом ключа
            if var in envs[key]: # Проверяем входит ли переменная в список переменных
                return key[-1] # Если да, но возвращаем имя этого пространства
            key = key[:-1] # Если нет, то из ключа (который генеалогическое дерево) отрезаем последний элемент
            if len(key) == 0: # Заодно проверяем что осталось от дерева. Если ничего
                return "None" # То возвращаем None
            namesp = key[-1] # Пространству для поиска присваиваем значение родителя

envs = {("global",): []}
com_lst = [input().split() for _ in range(int(input()))]
for name, com1, com2 in com_lst:
    if name == "create":
        create(com1, com2)
    elif name == "add":
        add(com1, com2)
    elif name == "get":
        print(get(com1, com2))
    else:
        print("Некорректный ввод запроса")

#TODO ++++++++++++++++++++++++++++++++++++++++++++++++
scopes = {'global': {'parent': None, 'variables': set()}}

# create <namespace> <parent> –  создать новое пространство имен
# с именем <namespace> внутри пространства <parent>
def create(n, p):
    scopes[n] = {'parent': None, 'variables': set()}
    scopes[n]['parent'] = p

# add <namespace> <var> – добавить в пространство <namespace> переменную <var>
def add(n, v):
    scopes[n]['variables'].add(v)

# get <namespace> <var>
# – получить имя пространства, из которого будет взята переменная <var>
#   при запросе из пространства <namespace>,
#   или None, если такого пространства не существует
def get(n, v):
    pr, vr = 'parent', 'variables'
    while scopes.get(n) is not None:
        if v in scopes.get(n, {}).get(vr): return n
        n = scopes.get(n, {}).get(pr)
    return

for _ in range(int(input())):
    cmd, name, arg = input().split()
    if cmd == 'create':
        create(name, arg)
    elif cmd == 'add':
        add(name, arg)
    elif cmd == 'get':
        print(get(name, arg))


# Реализуйте класс MoneyBox, для работы с виртуальной копилкой.
# Каждая копилка имеет ограниченную вместимость, которая выражается целым числом – количеством монет, которые можно положить в копилку. Класс должен поддерживать информацию о количестве монет в копилке, предоставлять возможность добавлять монеты в копилку и узнавать, можно ли добавить в копилку ещё какое-то количество монет, не превышая ее вместимость.
# Класс должен иметь следующий вид
#
# class MoneyBox:
#     def __init__(self, capacity):
#     # конструктор с аргументом – вместимость копилки
#
#     def can_add(self, v):
#         # True, если можно добавить v монет, False иначе
#
#     def add(self, v):
#         # положить v монет в копилку
# При создании копилки, число монет в ней равно 0.
# Примечание:
# Гарантируется, что метод add(self, v) будет вызываться только если can_add(self, v)
# Решение



class MoneyBox:
    def __init__(self, capacity):
        self.count_coin = 0
        self.capacity = capacity

    def can_add(self, v):
        return self.count_coin + v <= self.capacity

    def add(self, v):
        if self.can_add(v):
            self.count_coin += v


# Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой последовательности, затем сумму второй пятерки, и т. д.
#
# Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. Например, сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.
#
# Реализуйте класс Buffer, который будет накапливать в себе элементы последовательности и выводить сумму пятерок последовательных элементов по мере их накопления.
#
# Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.
#
# Класс должен иметь следующий вид

# class Buffer:
#     def __init__(self):
#         # конструктор без аргументов
#     def add(self, *a):
#         # добавить следующую часть последовательности
#     def get_current_part(self):
#         # вернуть сохраненные в текущий момент элементы последовательности в порядке, в котором они были
#         # добавлены
# Пример работы с классом
# buf = Buffer()
# buf.add(1, 2, 3)
# buf.get_current_part() # вернуть [1, 2, 3]
# buf.add(4, 5, 6) # print(15) – вывод суммы первой пятерки элементов
# buf.get_current_part() # вернуть [6]
# buf.add(7, 8, 9, 10) # print(40) – вывод суммы второй пятерки элементов
# buf.get_current_part() # вернуть []
# buf.add(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) # print(5), print(5) – вывод сумм третьей и четвертой пятерки
# buf.get_current_part() # вернуть [1]
# Обратите внимание, что во время выполнения метода add выводить сумму пятерок может
# потребоваться несколько раз до тех пор, пока в буфере не останется менее пяти элементов.
class Buffer:
    def __init__(self):
        self.part = []

    def add(self, *a):
        for i in a:
            self.part.append(i)
            if len(self.part) == 5:
                print(sum(self.part))
                self.part.clear()

    def get_current_part(self):
        return self.part

class Buffer:
    def __init__(self):
        self.items = []

    def add(self, *a):
        self.items += list(a)
        if len(self.items) >= 5:
            for i in self.items[4::5]:
                print(sum(self.items[:5]))
                self.items = self.items[5:]

    def get_current_part(self):
        return self.items


class Buffer:
    def __init__(self):
        # конструктор без аргументов
        self.value = []

    def add(self, *a):
        # добавить следующую часть последовательности.
        # просто увеличим наш список 'value'
        # на величину кортежа 'a', Python просто чудо!
        self.value += a
        while len(self.value) >= 5:
            # суммируем первые 5 элементов, это
            # так просто! красота!
            print(sum(self.value[0:5]))
            # переприсваиваем в атрибут списка 'value'
            # все его же элементы после 5-го!
            self.value = self.value[5:]
            # интересно, что сделает интерпретатор
            # со старым значением в памяти после
            # переприсваивания?

    def get_current_part(self):
        # вернуть сохраненные в текущий момент
        # элементы последовательности в порядке,
        # в котором они были добавлены
        return self.value

    class Buffer:
        def __init__(self):
            self.items = []

        def add(self, *a):
            for i in a:
                self.items.append(i)
                if len(self.items) == 5:
                    print(sum(self.items))
                    self.items = []

        def get_current_part(self):
            return self.items

class Buffer:

    def __init__(self):
        self.current_part = []

    def add(self, *a):
        self.current_part.extend(a)
        while len(self.current_part) - 5 >= 0:
            print(sum(self.current_part[0:5]))
            self.current_part = self.current_part[5:]



# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class A:
    val = 1

    def foo(self):
        # мы всегда обращаемся к атрибуту класса, из любого экземпляра
        A.val = A.val + 2

    def bar(self):
        # во время первого вызова bar это обращение к атрибуту класса,
        # т.к. у экземпляра класса еще нет атрибута val
        # |
        # |
        self.val = self.val + 1
        # |
        # |
        # после присвоения, у экземпляра появится свой атрибут val,
        # все последующие вызовы bar будут работать с ним

a = A()  # инстанс класса А, у него нет своего атрибута val
b = A()  # инстанс класса А, у него нет своего атрибута val

A.bar(a)  # у экземпляра a появился свой атрибут a.val = A.val + 1
A.foo(a)  # изменение атрибута класса A.val = A.val + 2

c = A()  # инстанс класса А, у него нет своего атрибута val


def get_current_part(self):
    return self.current_part




# Вам дано описание наследования классов в следующем формате.
#
# имя класса 1 : имя класса 2 имя класса 3 ... имя класса k
#
# Это означает, что класс 1 отнаследован от класса 2, класса 3, и т. д.
#
# Или эквивалентно записи:
#
# class Class1(Class2, Class3 ... ClassK):
#     pass
# Класс A является прямым предком класса B, если B отнаследован от A:
#
# class B(A):
#     pass
# Класс A является предком класса B, если
#
# A = B
# A - прямой предок B
# существует такой класс C, что C - прямой предок B и A - предок C
# Например:
#
# class B(A):
#     pass
#
# class C(B):
#     pass
#
# # A -- предок С
# Вам необходимо отвечать на запросы, является ли один класс предком другого класса
#
# Важное примечание:
#
# Создавать классы не требуется.
#
# Мы просим вас промоделировать этот процесс, и понять существует ли путь от одного класса до другого.
#
# Формат входных данных
#
# В первой строке входных данных содержится целое число n - число классов.
#
# В следующих n строках содержится описание наследования классов. В i-й строке указано от каких классов наследуется i-й класс. Обратите внимание, что класс может ни от кого не наследоваться. Гарантируется, что класс не наследуется сам от себя (прямо или косвенно), что класс не наследуется явно от одного класса более одного раза.
#
# В следующей строке содержится число q - количество запросов.
#
# В следующих q строках содержится описание запросов в формате имя класса 1 имя класса 2.
#
# Имя класса – строка, состоящая из символов латинского алфавита, длины не более 50.
#
# Формат выходных данных
#
# Для каждого запроса выведите в отдельной строке слово "Yes", если класс 1 является предком класса 2, и "No", если не является.
#
# ** Sample Input**:
#
# 4
# A
# B : A
# C : A
# D : B C
# 4
# A B
# B D
# C D
# D A
# Sample Output:
#
# Yes
# Yes
# Yes
# No

classes = {}

def add_class(classes, class_name, parents):
    if class_name not in classes:
        classes[class_name] = []
    classes[class_name].extend(parents)
    for parent in parents:
        if parent not in classes:
            classes[parent] = []

def found_path(classes, start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if start not in classes:
        return None
    for node in classes[start]:
        if node not in path:
            newpath = found_path(classes, node, end, path)
            if newpath: return newpath
    return None

def answer(classes, parent, child):
    if not(parent or child) in classes or not found_path(classes, child, parent):
        return 'No'
    return 'Yes'

n = int(input())
for _ in range(n):
    class_description = input().split()
    class_name = class_description[0]
    class_parents = class_description[2:]
    add_class(classes, class_name, class_parents)

q = int(input())
for _ in range(q):
    question = input().split()
    parent = question[0]
    child = question[1]
    print(answer(classes, parent, child))



    # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    clas = {}  # словарь наследник : предки


    def find_cls(A, B):
        if A == B:  # если A = B
            return True
        elif A in clas[B]:  # если А прямой предок В
            return True
        else:
            for C in clas[B]:  # если есть С прямой предок В и, не обязательно прямой, но предок А
                if find_cls(A, C):
                    return True
            return False


    for _ in range(int(input())):  # заполняем словарь
        inp = str(input()).split()
        clas.update({inp[0]: set(
            inp[2:])})  # хотел делать через множество на случай пересоздания класса. Не реализовал и не пригодилось

    for _ in range(int(input())):  # проверяем классы через функцию
        inp = (str(input()).split())
        cls1, cls2 = inp[0], inp[1]
        if find_cls(cls1, cls2):
            print("Yes")
        else:
            print("No")

#
# Реализуйте структуру данных, представляющую собой расширенную структуру стек.
# Необходимо поддерживать добавление элемента на вершину стека, удаление с вершины
# стека, и необходимо поддерживать операции сложения, вычитания, умножения и
# целочисленного деления.
# Операция сложения на стеке определяется следующим образом. Со стека снимается
# верхний элемент (top1), затем снимается следующий верхний элемент (top2), и
# затем как результат операции сложения на вершину стека кладется элемент, равный
# top1 + top2.
# Аналогичным образом определяются операции вычитания (top1 - top2), умножения
# (top1 * top2) и целочисленного деления (top1 // top2).
# Реализуйте эту структуру данных как класс ExtendedStack, отнаследовав его от
# стандартного класса list.
# Требуемая структура класса:
# class ExtendedStack(list):
#     def sum(self):
#         # операция сложения
#     def sub(self):
#         # операция вычитания
#     def mul(self):
#         # операция умножения
#     def div(self):
#         # операция целочисленного деления
# '''

class ExtendedStack(list):
    def sum(self):
        op1, op2 = self.pop(), self.pop()
        self.append(op1 + op2)

    def sub(self):
        op1, op2 = self.pop(), self.pop()
        self.append(op1 - op2)

    def mul(self):
        op1, op2 = self.pop(), self.pop()
        self.append(op1 * op2)

    def div(self):
        op1, op2 = self.pop(), self.pop()
        self.append(op1 // op2)

def test():
    ex_stack = ExtendedStack([1, 2, 3, 4, -3, 3, 5, 10])
    ex_stack.div()
    assert ex_stack.pop() == 2
    ex_stack.sub()
    assert ex_stack.pop() == 6
    ex_stack.sum()
    assert ex_stack.pop() == 7
    ex_stack.mul()
    assert ex_stack.pop() == 2
    assert len(ex_stack) == 0

if __name__ == "__main__":
    test()


# Вашей программе будет доступна функция foo, которая может бросать исключения.
#
# Вам необходимо написать код, который запускает эту функцию, затем ловит исключения
# ArithmeticError, AssertionError, ZeroDivisionError и выводит имя пойманного исключения.
#
# Пример решения, которое вы должны отправить на проверку.
#
# try:
#     foo()
# except Exception:
#     print("Exception")
# except BaseException:
#     print("BaseException")
# Подсказка: https://docs.python.org/3/library/exceptions.html#exception-hierarchy

try:
    foo()
except ZeroDivisionError:
    print('ZeroDivisionError')
except ArithmeticError:
    print('ArithmeticError')
except AssertionError:
    print('AssertionError')



# Вам дано описание наследования классов исключений в следующем формате.
#
# имя исключения 1 : имя исключения 2 имя исключения 3 ... имя исключения k
#
# Это означает, что исключение 1 наследуется от исключения 2, исключения 3, и т. д.
#
# Или эквивалентно записи:
#
# class Error1(Error2, Error3 ... ErrorK):
#     pass
# Антон написал код, который выглядит следующим образом.
#
# try:
#    foo()
# except <имя 1>:
#    print("<имя 1>")
# except <имя 2>:
#    print("<имя 2>")
# ...
# Костя посмотрел на этот код и указал Антону на то, что некоторые исключения можно не ловить, так как ранее в коде будет пойман их предок. Но Антон не помнит какие исключения наследуются от каких. Помогите ему выйти из неловкого положения и напишите программу, которая будет определять обработку каких исключений можно удалить из кода.
#
# Важное примечание:
#
# В отличие от предыдущей задачи, типы исключений не созданы.
#
# Создавать классы исключений также не требуется
#
# Мы просим вас промоделировать этот процесс, и понять какие из исключений можно и не ловить, потому что мы уже ранее где-то поймали их предка.
#
# Формат входных данных
#
# В первой строке входных данных содержится целое число n - число классов исключений.
#
# В следующих n строках содержится описание наследования классов. В i-й строке указано от каких классов наследуется i-й класс. Обратите внимание, что класс может ни от кого не наследоваться. Гарантируется, что класс не наследуется сам от себя (прямо или косвенно), что класс не наследуется явно от одного класса более одного раза.
#
# В следующей строке содержится число m - количество обрабатываемых исключений. Следующие m строк содержат имена исключений в том порядке, в каком они были написаны у Антона в коде. Гарантируется, что никакое исключение не обрабатывается дважды.
#
# Формат выходных данных
#
# Выведите в отдельной строке имя каждого исключения, обработку которого можно удалить из кода, не изменив при этом поведение программы. Имена следует выводить в том же порядке, в котором они идут во входных данных.
#
# Пример теста 1
#
# Рассмотрим код
#
# try:
#    foo()
# except ZeroDivision :
#    print("ZeroDivision")
# except OSError:
#    print("OSError")
# except ArithmeticError:
#    print("ArithmeticError")
# except FileNotFoundError:
#    print("FileNotFoundError")
# ...
# По условию этого теста, Костя посмотрел на этот код, и сказал Антону, что исключение FileNotFoundError можно не ловить, ведь мы уже ловим OSError -- предок FileNotFoundError
#
# Sample Input:
# 4
# ArithmeticError
# ZeroDivisionError : ArithmeticError
# OSError
# FileNotFoundError : OSError
# 4
# ZeroDivisionError
# OSError
# ArithmeticError
# FileNotFoundError
# Sample Output:
# FileNotFoundError